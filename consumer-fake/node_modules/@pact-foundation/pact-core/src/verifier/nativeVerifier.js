"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verify = void 0;
var logger_1 = require("../logger");
var ffi_1 = require("../ffi");
var types_1 = require("../ffi/types");
var url_1 = require("url");
var pkg = require('../../package.json');
var fs = require("fs");
var objArrayToStringArray = function (obj) {
    return obj.map(function (o) { return JSON.stringify(o); });
};
var verify = function (opts) {
    var ffi = ffi_1.getFfiLib(opts.logLevel);
    if (opts.logLevel) {
        logger_1.setLogLevel(opts.logLevel);
    }
    var handle = ffi.pactffiVerifierNewForApplication(pkg.name.split('/')[1], pkg.version);
    var uri = new url_1.URL(opts.providerBaseUrl);
    ffi.pactffiVerifierSetProviderInfo(handle, opts.provider || '', uri.protocol.split(':')[0], uri.hostname, parseInt(uri.port, 10), uri.pathname);
    if (opts.providerStatesSetupUrl) {
        ffi.pactffiVerifierSetProviderState(handle, opts.providerStatesSetupUrl, opts.providerStatesSetupTeardown || true, opts.providerStatesSetupBody || true);
    }
    Object.keys(opts.customProviderHeaders || {}).forEach(function (key, _, obj) {
        return ffi.pactffiVerifierAddCustomHeader(handle, key, obj[key]);
    });
    var filterDescription = process.env.PACT_DESCRIPTION || '';
    var filterState = process.env.PACT_PROVIDER_STATE || '';
    var filterNoState = process.env.PACT_PROVIDER_NO_STATE ? true : false;
    ffi.pactffiVerifierSetFilterInfo(handle, filterDescription, filterState, filterNoState);
    if (opts.pactUrls) {
        opts.pactUrls.forEach(function (file) {
            logger_1.default.debug("checking source type of given pactUrl: " + file);
            try {
                var u = new url_1.URL(file);
                if (u.hostname) {
                    logger_1.default.debug("adding " + file + " as a Url source");
                    ffi.pactffiVerifierUrlSource(handle, file, opts.pactBrokerUsername || '', opts.pactBrokerPassword || '', opts.pactBrokerToken || '');
                }
            }
            catch (_a) {
                logger_1.default.debug(file + " is not a URI");
            }
            try {
                var f = fs.lstatSync(file);
                if (f.isDirectory()) {
                    logger_1.default.debug("adding " + file + " as Directory source");
                    ffi.pactffiVerifierAddDirectorySource(handle, file);
                }
                else if (f.isFile() || f.isSymbolicLink()) {
                    logger_1.default.debug("adding " + file + " as File source");
                    ffi.pactffiVerifierAddFileSource(handle, file);
                }
            }
            catch (_b) {
                logger_1.default.debug(file + " is not a file");
            }
        });
    }
    if (opts.disableSslVerification || opts.timeout) {
        ffi.pactffiVerifierSetVerificationOptions(handle, opts.disableSslVerification || false, opts.timeout || 30000);
    }
    if (opts.publishVerificationResult ||
        opts.providerVersion ||
        opts.buildUrl ||
        opts.disableSslVerification ||
        opts.timeout ||
        opts.providerVersionTags) {
        ffi.pactffiVerifierSetPublishOptions(handle, opts.providerVersion || '', opts.buildUrl || '', opts.providerVersionTags || [], opts.providerBranch || '');
    }
    var brokerUrl = opts.pactBrokerUrl || process.env.PACT_BROKER_BASE_URL;
    if (brokerUrl && opts.provider) {
        ffi.pactffiVerifierBrokerSourceWithSelectors(handle, brokerUrl, opts.pactBrokerUsername || process.env.PACT_BROKER_USERNAME || '', opts.pactBrokerPassword || process.env.PACT_BROKER_PASSWORD || '', opts.pactBrokerToken || process.env.PACT_BROKER_TOKEN || '', opts.enablePending || false, opts.includeWipPactsSince || '', opts.providerVersionTags || [], opts.providerBranch || '', opts.consumerVersionSelectors
            ? objArrayToStringArray(opts.consumerVersionSelectors)
            : [], opts.consumerVersionTags || []);
    }
    return new Promise(function (resolve, reject) {
        ffi.pactffiVerifierExecute(handle, function (err, res) {
            logger_1.default.debug("shutting down verifier with handle " + handle);
            ffi.pactffiVerifierShutdown(handle);
            logger_1.default.debug("response from verifier: " + err + ", " + res);
            if (err) {
                if (typeof err === 'string') {
                    logger_1.default.error(err);
                }
                else if (err.message) {
                    logger_1.default.error(err.message);
                }
                logger_1.default.pactCrash('The underlying pact core returned an error through the ffi interface');
                reject(err);
            }
            else {
                switch (res) {
                    case types_1.VERIFY_PROVIDER_RESPONSE.VERIFICATION_SUCCESSFUL:
                        logger_1.default.info('Verification successful');
                        resolve("finished: " + res);
                        break;
                    case types_1.VERIFY_PROVIDER_RESPONSE.VERIFICATION_FAILED:
                        logger_1.default.error('Verification unsuccessful');
                        reject(new Error('Verfication failed'));
                        break;
                    case types_1.VERIFY_PROVIDER_RESPONSE.INVALID_ARGUMENTS:
                        logger_1.default.pactCrash('The underlying pact core was invoked incorrectly.');
                        reject(new Error('Verification was unable to run'));
                        break;
                    default:
                        logger_1.default.pactCrash('The underlying pact core crashed in an unexpected way.');
                        reject(new Error('Pact core crashed'));
                        break;
                }
            }
        });
    });
};
exports.verify = verify;
//# sourceMappingURL=nativeVerifier.js.map