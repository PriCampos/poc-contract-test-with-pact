"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeConsumerAsyncMessagePact = exports.makeConsumerPact = void 0;
var types_1 = require("../ffi/types");
var logger_1 = require("../logger");
var checkErrors_1 = require("./checkErrors");
var ffi_1 = require("../ffi");
var makeConsumerPact = function (consumer, provider, version, logLevel) {
    if (version === void 0) { version = 3; }
    if (logLevel === void 0) { logLevel = logger_1.getLogLevel(); }
    var ffi = ffi_1.getFfiLib(logLevel);
    if (logLevel) {
        logger_1.setLogLevel(logLevel);
    }
    var pactPtr = ffi.pactffiNewPact(consumer, provider);
    if (!ffi.pactffiWithSpecification(pactPtr, version)) {
        throw new Error("Unable to set core spec version. The pact FfiSpecificationVersion '" + version + "' may be invalid (note this is not the same as the pact spec version)");
    }
    return {
        addPlugin: function (name, version) {
            ffi.pactffiUsingPlugin(pactPtr, name, version);
        },
        cleanupPlugins: function () {
            ffi.pactffiCleanupPlugins(pactPtr);
        },
        createMockServer: function (address, requestedPort, tls) {
            if (tls === void 0) { tls = false; }
            var port = ffi.pactffiCreateMockServerForPact(pactPtr, address + ":" + (requestedPort ? requestedPort : 0), tls);
            var error = Object.keys(types_1.CREATE_MOCK_SERVER_ERRORS).find(function (key) { return types_1.CREATE_MOCK_SERVER_ERRORS[key] === port; });
            if (error) {
                if (error === 'ADDRESS_NOT_VALID') {
                    logger_1.logErrorAndThrow("Unable to start mock server at '" + address + "'. Is the address and port valid?");
                }
                if (error === 'TLS_CONFIG') {
                    logger_1.logErrorAndThrow("Unable to create TLS configuration with self-signed certificate");
                }
                logger_1.logCrashAndThrow("The pact core couldn't create the mock server because of an error described by '" + error + "'");
            }
            if (port <= 0) {
                logger_1.logCrashAndThrow("The pact core returned an unhandled error code '" + port + "'");
            }
            return port;
        },
        mockServerMatchedSuccessfully: function (port) {
            return ffi.pactffiMockServerMatched(port);
        },
        mockServerMismatches: function (port) {
            var results = JSON.parse(ffi.pactffiMockServerMismatches(port));
            return results.map(function (result) { return (__assign(__assign({}, result), ('mismatches' in result
                ? {
                    mismatches: result.mismatches.map(function (m) {
                        return typeof m === 'string' ? JSON.parse(m) : m;
                    }),
                }
                : {}))); });
        },
        cleanupMockServer: function (port) {
            return checkErrors_1.wrapWithCheck(function (port) { return ffi.pactffiCleanupMockServer(port); }, 'cleanupMockServer')(port);
        },
        writePactFile: function (dir, merge) {
            if (merge === void 0) { merge = true; }
            return writePact(ffi, pactPtr, dir, merge);
        },
        addMetadata: function (namespace, name, value) {
            return ffi.pactffiWithPactMetadata(pactPtr, namespace, name, value);
        },
        newInteraction: function (description) {
            var interactionPtr = ffi.pactffiNewInteraction(pactPtr, description);
            return checkErrors_1.wrapAllWithCheck({
                uponReceiving: function (description) {
                    return ffi.pactffiUponReceiving(interactionPtr, description);
                },
                given: function (state) {
                    return ffi.pactffiGiven(interactionPtr, state);
                },
                givenWithParam: function (state, name, value) {
                    return ffi.pactffiGivenWithParam(interactionPtr, state, name, value);
                },
                withRequest: function (method, path) {
                    return ffi.pactffiWithRequest(interactionPtr, method, path);
                },
                withQuery: function (name, index, value) {
                    return ffi.pactffiWithQueryParameter(interactionPtr, name, index, value);
                },
                withRequestHeader: function (name, index, value) {
                    return ffi.pactffiWithHeader(interactionPtr, types_1.INTERACTION_PART_REQUEST, name, index, value);
                },
                withRequestBody: function (body, contentType) {
                    return ffi.pactffiWithBody(interactionPtr, types_1.INTERACTION_PART_REQUEST, contentType, body);
                },
                withRequestBinaryBody: function (body, contentType) {
                    return ffi.pactffiWithBinaryFile(interactionPtr, types_1.INTERACTION_PART_REQUEST, contentType, body, body.length);
                },
                withRequestMultipartBody: function (contentType, filename, mimePartName) {
                    return (ffi.pactffiWithMultipartFile(interactionPtr, types_1.INTERACTION_PART_REQUEST, contentType, filename, mimePartName) === undefined);
                },
                withResponseHeader: function (name, index, value) {
                    return ffi.pactffiWithHeader(interactionPtr, types_1.INTERACTION_PART_RESPONSE, name, index, value);
                },
                withResponseBody: function (body, contentType) {
                    return ffi.pactffiWithBody(interactionPtr, types_1.INTERACTION_PART_RESPONSE, contentType, body);
                },
                withResponseBinaryBody: function (body, contentType) {
                    return ffi.pactffiWithBinaryFile(interactionPtr, types_1.INTERACTION_PART_RESPONSE, contentType, body, body.length);
                },
                withResponseMultipartBody: function (contentType, filename, mimePartName) {
                    return (ffi.pactffiWithMultipartFile(interactionPtr, types_1.INTERACTION_PART_RESPONSE, contentType, filename, mimePartName) === undefined);
                },
                withStatus: function (status) {
                    return ffi.pactffiResponseStatus(interactionPtr, status);
                },
                withPluginRequestInteractionContents: function (contentType, contents) {
                    ffi.pactffiPluginInteractionContents(interactionPtr, types_1.INTERACTION_PART_REQUEST, contentType, contents);
                    return true;
                },
                withPluginResponseInteractionContents: function (contentType, contents) {
                    ffi.pactffiPluginInteractionContents(interactionPtr, types_1.INTERACTION_PART_RESPONSE, contentType, contents);
                    return true;
                },
            });
        },
    };
};
exports.makeConsumerPact = makeConsumerPact;
var makeConsumerAsyncMessagePact = function (consumer, provider, version, logLevel) {
    if (version === void 0) { version = 4; }
    if (logLevel === void 0) { logLevel = logger_1.getLogLevel(); }
    var ffi = ffi_1.getFfiLib(logLevel);
    if (logLevel) {
        logger_1.setLogLevel(logLevel);
    }
    var pactPtr = ffi.pactffiNewPact(consumer, provider);
    if (!ffi.pactffiWithSpecification(pactPtr, version) || version < 4) {
        throw new Error("Unable to set core spec version. The pact FfiSpecificationVersion '" + version + "' may be invalid (note this is not the same as the pact spec version). It should be set to at least 3");
    }
    return {
        addPlugin: function (name, version) {
            ffi.pactffiUsingPlugin(pactPtr, name, version);
        },
        cleanupPlugins: function () {
            ffi.pactffiCleanupPlugins(pactPtr);
        },
        writePactFile: function (dir, merge) {
            if (merge === void 0) { merge = true; }
            return writePact(ffi, pactPtr, dir, merge);
        },
        addMetadata: function (namespace, name, value) {
            return ffi.pactffiWithPactMetadata(pactPtr, namespace, name, value);
        },
        newMessage: function (description) {
            var interactionPtr = ffi.pactffiNewAsyncMessage(pactPtr, description);
            return {
                withPluginRequestInteractionContents: function (contentType, contents) {
                    ffi.pactffiPluginInteractionContents(interactionPtr, types_1.INTERACTION_PART_REQUEST, contentType, contents);
                    return true;
                },
                withPluginResponseInteractionContents: function (contentType, contents) {
                    ffi.pactffiPluginInteractionContents(interactionPtr, types_1.INTERACTION_PART_RESPONSE, contentType, contents);
                    return true;
                },
                expectsToReceive: function (description) {
                    return ffi.pactffiMessageExpectsToReceive(interactionPtr, description);
                },
                given: function (state) {
                    return ffi.pactffiMessageGiven(interactionPtr, state);
                },
                givenWithParam: function (state, name, value) {
                    return ffi.pactffiMessageGivenWithParam(interactionPtr, state, name, value);
                },
                withContents: function (body, contentType) {
                    return ffi.pactffiMessageWithContents(interactionPtr, contentType, body);
                },
                withBinaryContents: function (body, contentType) {
                    return ffi.pactffiMessageWithBinaryContents(interactionPtr, contentType, body, body.length);
                },
                reifyMessage: function () {
                    return ffi.pactffiMessageReify(interactionPtr);
                },
                withMetadata: function (name, value) {
                    return ffi.pactffiMessageWithMetadata(interactionPtr, name, value);
                },
            };
        },
    };
};
exports.makeConsumerAsyncMessagePact = makeConsumerAsyncMessagePact;
var writePact = function (ffi, pactPtr, dir, merge) {
    if (merge === void 0) { merge = true; }
    var result = ffi.pactffiWritePactFile(pactPtr, dir, !merge);
    switch (result) {
        case types_1.FfiWritePactResponse.SUCCESS:
            return;
        case types_1.FfiWritePactResponse.UNABLE_TO_WRITE_PACT_FILE:
            logger_1.logErrorAndThrow('The pact core was unable to write the pact file');
        case types_1.FfiWritePactResponse.GENERAL_PANIC:
            logger_1.logCrashAndThrow('The pact core panicked while writing the pact file');
        case types_1.FfiWritePactResponse.MOCK_SERVER_NOT_FOUND:
            logger_1.logCrashAndThrow('The pact core was asked to write a pact file from a mock server that appears not to exist');
        default:
            logger_1.logCrashAndThrow("The pact core returned an unknown error code (" + result + ") instead of writing the pact");
    }
};
__exportStar(require("./types"), exports);
//# sourceMappingURL=index.js.map