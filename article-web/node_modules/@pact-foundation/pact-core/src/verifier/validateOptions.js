"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateOptions = void 0;
var checkTypes = require("check-types");
var logger_1 = require("../logger");
var LogLevels = ['debug', 'error', 'info', 'trace', 'warn'];
var validateOptions = function (o) {
    var options = __assign({}, o);
    if (options.logLevel) {
        if (LogLevels.includes(options.logLevel.toLowerCase())) {
            options.logLevel = options.logLevel.toLowerCase();
        }
        else {
            throw new Error("The logLevel '" + options.logLevel + "' is not a valid logLevel. The valid options are: " + LogLevels.join(', '));
        }
    }
    if (options.providerVersionTags) {
        if (!checkTypes.string(options.providerVersionTags) &&
            !checkTypes.array.of.string(options.providerVersionTags)) {
            throw new Error('providerVersionTags should be a string or an array of strings');
        }
        if (options.providerVersionTags.includes('latest')) {
            logger_1.default.warn("Using the tag 'latest' is not recommended and probably does not do what you intended.");
            logger_1.default.warn('    See https://docs.pact.io/pact_broker/tags/#latest-pacts');
        }
    }
    if (options.consumerVersionTags) {
        if (!checkTypes.string(options.consumerVersionTags) &&
            !checkTypes.array.of.string(options.consumerVersionTags)) {
            throw new Error('consumerVersionTags should be a string or an array of strings');
        }
        if (options.consumerVersionTags.includes('latest')) {
            logger_1.default.warn("Using the tag 'latest' is not recommended and probably does not do what you intended.");
            logger_1.default.warn('    See https://docs.pact.io/pact_broker/tags/#latest-pacts');
            logger_1.default.warn('    If you need to specify latest, try:');
            logger_1.default.warn('       consumerVersionSelectors: [{ lastest: true }]');
        }
    }
    if (options.consumerVersionSelectors &&
        Array.isArray(options.consumerVersionSelectors)) {
        var PROPS_1 = [
            'tag',
            'latest',
            'consumer',
            'deployedOrReleased',
            'deployed',
            'released',
            'environment',
            'fallbackTag',
            'branch',
            'mainBranch',
            'matchingBranch',
        ];
        options.consumerVersionSelectors.forEach(function (selector) {
            if (selector.tag === 'latest') {
                logger_1.default.warn("Using the tag 'latest' is not recommended and probably does not do what you intended.");
                logger_1.default.warn('    See https://docs.pact.io/pact_broker/tags/#latest-pacts');
                logger_1.default.warn('    If you need to specify latest, try:');
                logger_1.default.warn('       consumerVersionSelectors: [{ lastest: true }]');
            }
            Object.keys(selector).forEach(function (key) {
                if (!PROPS_1.includes(key)) {
                    throw new Error("The property '" + key + "' is not a valid property of ConsumerVersionSelector. Allowed properties are " + PROPS_1.join(', ') + ")");
                }
            });
        });
    }
    if (options.includeWipPactsSince !== undefined) {
        checkTypes.assert.nonEmptyString(options.includeWipPactsSince, 'includeWipPactsSince should be a non-empty string');
    }
    checkTypes.assert.nonEmptyString(options.providerBaseUrl, 'providerBaseUrl must be a non-empty string');
    if ((!options.pactUrls ||
        checkTypes.emptyArray(options.pactUrls)) &&
        !options.pactBrokerUrl) {
        throw new Error('Must provide the pactUrls argument if no pactBrokerUrl provided');
    }
    if ((!options.pactBrokerUrl || !options.provider) &&
        (!options.pactUrls || checkTypes.emptyArray(options.pactUrls))) {
        throw new Error('Must provide both provider and pactBrokerUrl if pactUrls not provided.');
    }
    if (options.providerStatesSetupUrl) {
        checkTypes.assert.string(options.providerStatesSetupUrl, 'providerStatesSetupUrl must be a non-empty string');
    }
    if (options.pactBrokerUsername) {
        checkTypes.assert.string(options.pactBrokerUsername, 'pactBrokerUsername must be a non-empty string');
    }
    if (options.pactBrokerPassword) {
        checkTypes.assert.string(options.pactBrokerPassword, 'pactBrokerPassword must be a string');
    }
    if (options.pactBrokerToken &&
        (options.pactBrokerUsername || options.pactBrokerPassword)) {
        throw new Error('Must provide pactBrokerToken or pactBrokerUsername/pactBrokerPassword but not both.');
    }
    if (options.pactBrokerUrl) {
        checkTypes.assert.string(options.pactBrokerUrl, 'pactBrokerUrl must be a string');
    }
    if (options.pactUrls) {
        checkTypes.assert.array.of.string(options.pactUrls, 'pactUrls must be an array of strings');
    }
    if (options.providerBaseUrl) {
        checkTypes.assert.string(options.providerBaseUrl, 'providerBaseUrl must be a string');
    }
    if (options.publishVerificationResult) {
        checkTypes.assert.boolean(options.publishVerificationResult, 'publishVerificationResult must be a boolean');
    }
    if (options.publishVerificationResult && !options.providerVersion) {
        throw new Error('Must provide both or none of publishVerificationResult and providerVersion.');
    }
    if (options.providerVersion) {
        checkTypes.assert.string(options.providerVersion, 'providerVersion must be a string');
    }
    if (options.enablePending !== undefined) {
        checkTypes.assert.boolean(options.enablePending, 'enablePending must be a boolean');
    }
    if (options.timeout) {
        checkTypes.assert.positive(options.timeout, 'timeout must be a positive number');
    }
    return options;
};
exports.validateOptions = validateOptions;
//# sourceMappingURL=validateOptions.js.map